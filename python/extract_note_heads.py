#!/usr/bin/env python3
"""
svg_extract_note_heads.py

SVG Musical Notehead Extraction Pipeline  
========================================

This script extracts notehead positions and pitch information from SVG files
generated by LilyPond music notation software. It creates a dataset mapping
visual notehead locations to their corresponding musical pitches for use in
animated score following applications.

Process Overview:
1. Parse LilyPond-generated SVG to find clickable notehead elements
2. Extract pitch information from LilyPond source code via href links (file paths embedded in href)
3. Determine visual coordinates for each notehead
4. Group simultaneous notes (chords) using x-coordinate tolerance
5. Create sorted dataset ordered by visual appearance (left-to-right, top-to-bottom)
6. Export CSV with required arguments for input SVG and output path

Input Files:
- SVG file with embedded LilyPond cross-references (href contains .ly file paths)

Output:
- CSV file with notehead coordinates, pitches, and reference links in format: snippet,href,x,y
"""

import re
import csv
import xml.etree.ElementTree as ET
import argparse
import os
import sys
import pandas as pd
from _scripts_utils import save_dataframe_with_lilypond_csv

# =============================================================================
# LILYPOND PITCH PATTERN MATCHING
# =============================================================================

# Regular expression to identify LilyPond note syntax in source code
# Matches: letter name + optional accidentals + optional octave marks
note_regex = re.compile(r"""
            ^                 # start of string
            ([a-g])        # pitch letter
            (isis|eses|is|es)?# optional accidentals
            \s*               # optional octave marks
            [,']*             # optional octave marks
        """, re.VERBOSE)

# =============================================================================
# LILYPOND SOURCE CODE PARSING FUNCTION
# =============================================================================

def extract_text_from_href(href):
    """
    Extract LilyPond pitch notation from cross-reference URLs.
    
    LilyPond embeds "textedit" URLs in SVG that point back to specific
    locations in the source .ly file. These URLs encode file path, line
    number, and column position, allowing us to extract the exact pitch
    notation that generated each visual notehead.
    
    Args:
        href (str): TextEdit URL from SVG (e.g., "textedit:///work/file.ly:25:10")
        
    Returns:
        str or None: LilyPond pitch notation (e.g., "cis'") or None if not found
        
    URL Format: textedit:///work/filepath:line:column
    - filepath: Path to .ly source file (extracted from href)
    - line: 1-based line number  
    - column: 1-based character position
    """
    try:
        # Clean up URL format - remove textedit protocol prefix
        if href.startswith("textedit:///work/"):
            href = href[len("textedit:///work/"):]
        else:
            return "(invalid href format)"

        # Parse URL components: "file.ly:line:column"
        parts = href.split(":")
        file_path = parts[0]
        line = int(parts[1]) - 1      # Convert to 0-based indexing
        col_start = int(parts[2])     # 1-based column position

        # Read the specific LilyPond source file referenced in the href
        with open(file_path, encoding="utf-8") as f:
            lines = f.readlines()

        # Extract text from the specified position to end of line
        text_line = lines[line][col_start:]
        text = text_line.strip().strip("[]<>()")
        
        # Attempt to match LilyPond note pattern
        match = note_regex.match(text)

        if match:
            # Return the matched note notation without extra whitespace
            return match.group(0).replace(" ", "")
        else:
            # Return None if no valid note pattern found
            return None

    except Exception as e:
        return f"(error: {e})"

def group_notes_by_x_tolerance(notes, tolerance=0.0):
    """
    Group notes by x-coordinate within tolerance to handle simultaneous notes (chords).
    
    LilyPond often places chord notes at slightly different x-coordinates for visual
    clarity, but they should be treated as simultaneous for MIDI alignment.
    
    Args:
        notes (list): List of notehead dictionaries with x, y coordinates
        tolerance (float): Maximum x-coordinate difference to consider simultaneous
        
    Returns:
        list: Notes sorted with chord members properly grouped
    """
    if not notes:
        return notes
        

    print(f"tolerance: ............. {tolerance}")
    # Sort by x-coordinate first for grouping
    notes_sorted = sorted(notes, key=lambda n: n["x"])
    
    groups = []
    current_group = [notes_sorted[0]]
    
    # Group notes within tolerance
    for note in notes_sorted[1:]:
        if abs(note["x"] - current_group[0]["x"]) <= tolerance:
            # Within tolerance - add to current group
            current_group.append(note)
        else:
            # Outside tolerance - start new group
            groups.append(current_group)
            current_group = [note]
    
    # Don't forget the last group
    groups.append(current_group)
    
    # Sort within each group by y-coordinate (top to bottom)
    # and sort groups by their representative x-coordinate
    result = []
    for group in groups:
        # Sort notes within group by y-coordinate (descending = top to bottom)
        group_sorted = sorted(group, key=lambda n: -n["y"])
        result.extend(group_sorted)
    
    return result

def setup_argument_parser():
    """Setup command line argument parser."""
    parser = argparse.ArgumentParser(
        description="Extract notehead positions and pitch information from SVG files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python extract_note_heads.py -i score.svg -o noteheads.csv
  python extract_note_heads.py --input music.svg --output music_note_heads.csv --tolerance 1.5
  python extract_note_heads.py -i score.svg -o noteheads.csv -t 3.0
        """
    )
    
    parser.add_argument('-i', '--input', 
                       required=True,
                       help='Input SVG file path (required)')
    
    parser.add_argument('-o', '--output',
                       required=True, 
                       help='Output CSV file path for noteheads (required)')
    
    parser.add_argument('-t', '--tolerance',
                       type=float,
                       default=1.0,
                       help='X-coordinate tolerance for grouping simultaneous notes (default: 2.0)')
    
    return parser.parse_args()

def main():
    """Main function with command line argument support."""
    
    print("üéº SVG Notehead Extractor")
    print("=" * 50)
    
    # Parse arguments
    args = setup_argument_parser()
    
    svg_file = args.input
    output_csv = args.output
    tolerance = args.tolerance
    
    print(f"üìÑ Input SVG: {svg_file}")
    print(f"üìä Output CSV: {output_csv}")
    print(f"üìè Chord tolerance: ¬±{tolerance} units")
    print()

    # =================================================================
    # XML NAMESPACE SETUP AND FILE LOADING
    # =================================================================

    try:
        print("üîç Loading and parsing SVG file...")

        # Verify SVG file exists
        if not os.path.exists(svg_file):
            raise FileNotFoundError(f"SVG file not found: {svg_file}")

        # Load SVG file
        with open(svg_file, encoding="utf-8") as f:
            svg = ET.parse(f)

        # SVG namespaces for XPath queries
        NS = {'svg': 'http://www.w3.org/2000/svg', 'xlink': 'http://www.w3.org/1999/xlink'}
        root = svg.getroot()

        # =================================================================
        # NOTEHEAD DISCOVERY AND COORDINATE EXTRACTION
        # =================================================================

        print("üìç Extracting notehead positions and pitch data...")

        # Storage for discovered noteheads
        notehead_data = []

        # Find all clickable <a> elements (these contain the noteheads)
        for a in root.findall(".//svg:a", NS):
            # Get the cross-reference URL
            href = a.get(f"{{{NS['xlink']}}}href")
            
            # Extract pitch information from the href
            snippet = extract_text_from_href(href)

            # Skip if we couldn't extract valid pitch information
            if not snippet is None:
                # Find the graphical group element containing visual positioning
                g = a.find("svg:g", NS)
                
                if g is not None:
                    # Extract coordinate transformation from the group's transform attribute
                    transform = g.attrib.get("transform", "")
                    
                    # Parse translation coordinates: "translate(x, y)" or "translate(x,y)"
                    match = re.search(r"translate\(([-\d.]+)[ ,]+([-\d.]+)", transform)
                    
                    if not match:
                        print(f"no matching transform near <a> of [{href}] for snippet [{snippet}]")
                    
                    if match:
                        # Extract and convert coordinates
                        x = float(match.group(1))
                        y = float(match.group(2))
                        
                        # Store the notehead information
                        notehead_data.append({
                            "x": x,
                            "y": y,
                            "href": href,
                            "snippet": snippet
                        })

        print(f"   üìä Processed {len(root.findall('.//svg:a', NS))} anchor elements")
        print(f"   ‚úÖ Found {len(notehead_data)} valid noteheads with pitch data") 

        # =================================================================
        # SPATIAL SORTING WITH TOLERANCE FOR SIMULTANEOUS NOTES
        # =================================================================

        print("üìê Sorting noteheads by visual position with chord tolerance...")

        # Apply tolerance-based sorting
        notehead_data = group_notes_by_x_tolerance(notehead_data, tolerance=tolerance)

        print(f"   üéØ Sorted {len(notehead_data)} noteheads with chord tolerance (¬±{tolerance} units)")
        
        # Show grouping statistics
        if notehead_data:
            x_positions = [n["x"] for n in notehead_data]
            unique_x_groups = 1
            for i in range(1, len(x_positions)):
                if abs(x_positions[i] - x_positions[i-1]) > tolerance:
                    unique_x_groups += 1
            
            print(f"   üìä Identified {unique_x_groups} distinct time positions")
            if unique_x_groups > 0:
                print(f"   üéµ Average notes per position: {len(notehead_data)/unique_x_groups:.1f}")

        # =================================================================
        # CSV EXPORT
        # =================================================================

        print(f"üíæ Writing results to {output_csv}...")

        # Convert notehead data to DataFrame for consistent CSV handling
        notehead_df = pd.DataFrame(notehead_data)
        
        # Reorder columns to match requested format: snippet, href, x, y
        notehead_df = notehead_df[["snippet", "href", "x", "y"]]
        
        # Round coordinates to 3 decimal precision
        notehead_df["x"] = notehead_df["x"].round(3)
        notehead_df["y"] = notehead_df["y"].round(3)
        
        # Use utility function to handle LilyPond notation CSV quoting
        save_dataframe_with_lilypond_csv(notehead_df, output_csv)

        # =================================================================
        # COMPLETION SUMMARY
        # =================================================================

        extraction_summary = f"[ extracted {len(notehead_data)} noteheads with coordinates and pitch data ]"
        print(f"‚úÖ Export complete: {output_csv} {extraction_summary}")

        # Additional statistics for verification
        if notehead_data:
            x_range = max(n["x"] for n in notehead_data) - min(n["x"] for n in notehead_data)
            y_range = max(n["y"] for n in notehead_data) - min(n["y"] for n in notehead_data)
            unique_pitches = len(set(n["snippet"] for n in notehead_data))
            
            print(f"\nüìä Extraction Statistics:")
            print(f"   üìè X-coordinate range: {x_range:.1f} units")
            print(f"   üìê Y-coordinate range: {y_range:.1f} units") 
            print(f"   üéµ Unique pitch notations: {unique_pitches}")
            if unique_pitches > 0:
                print(f"   üîó Average notes per pitch: {len(notehead_data)/unique_pitches:.1f}")

        print()
        print("üéâ Notehead extraction completed successfully!")
        print(f"üéØ Ready for alignment with MIDI data in next pipeline stage")

    except FileNotFoundError as e:
        print(f"‚ùå File error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()